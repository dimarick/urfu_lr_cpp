#include <iostream>

using namespace std;
void swap1(int a, int b);
void swap2(int *a, int *b);
void swap3(int &a, int &b);

int main (void) {
    int a = 2, b = 5;

    cout << "До обмена:\t a=" << a << ", b=" << b << endl;
    swap1(a, b);
    cout << "После обмена:\t a=" << a << ", b=" << b << endl;

    cout << "До обмена:\t a=" << a << ", b=" << b << endl;
    swap2(&a, &b);
    cout << "После обмена:\t a=" << a << ", b=" << b << endl;

    cout << "До обмена:\t a=" << a << ", b=" << b << endl;
    swap3(a, b);
    cout << "После обмена:\t a=" << a << ", b=" << b << endl;
}

// При передаче по значению, результат недостижим, т.к. функция не имеет никакой возможности для записи в память вызывающего
void swap1(int a, int b) {
    auto t = a;
    a = b;
    b = t;
}

// При передаче указателей вместо значений, мы можем обменять значения в соответствующих ячейках памяти
// Очень простая и близкая к "железу" концепция: есть адреса ячеек памяти и есть значения в них.
void swap2(int *a, int *b) {
    auto t = *a;
    *a = *b;
    *b = t;
}

// Здесь происходит тоже самое что и в swap2, но взятие указателя и его разыменовывание происходит автоматически
// Если подробнее, то здесь происходит следующее:
// Переменная int a вызывающего, присваивается ссылочному типу int &a, который описан как аргумент функции
// Далее int &a ведет себя также как int, но чтение/запись a будет вестись по адресу переменной вызывающей функции
// тело swap2 и swap3, а также их вызовы дадут одинаковый (или очень близкий) машинный код,
// однако ссылочные переменные - гораздо более высокоуровневая концепция
void swap3(int &a, int &b) {
    auto t = a;
    a = b;
    b = t;
}
